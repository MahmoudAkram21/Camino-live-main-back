# استهلاك موارد السيرفر عند الـ Deploy – الأسباب والحلول

> **هيكلة الباك اند:** تفاصيل الأخطاء الهيكلية اللي كانت بتسبب المشاكل والتعديلات اللي اتعملت موجودة في [BACKEND_ARCHITECTURE.md](./BACKEND_ARCHITECTURE.md).

---

## Schema و MySQL – مهم جداً

**التطبيق لا يرسم الـ schema تلقائياً.** لا يوجد في الكود أي استدعاء لـ `sequelize.sync()` أو migrations عند التشغيل. الـ schema يُنشأ **مرة واحدة** في MySQL بتشغيل ملف `database/schema.sql`.

**على Coolify (أو أي منصة deploy):**
- **لا تضف** في Build Command أو Start Command أو Deploy Command أي من:
  - `npm run migrate`
  - `npm run seed`
  - `npm run clear-and-reseed`
  - `npm run migrate:languages`
- **Start Command** يكون فقط: `npm start` أو `node src/server.js` (أو `npm run start:prod`).
- **الـ schema:** شغّل `database/schema.sql` **مرة واحدة** على قاعدة MySQL (مثلاً من phpMyAdmin أو MySQL CLI).
- **الـ seed (بيانات أولية):** لو محتاج بيانات تجريبية، شغّل `npm run seed` **يدوياً مرة واحدة** بعد تشغيل الـ schema، وليس كجزء من الـ deploy.

لو كان الـ deploy بيشغّل migrate أو seed أو clear-and-reseed مع كل نشر، ده بيسبب تحميل زائد على MySQL و"رسم" متكرر للـ schema أو إعادة تعبئة البيانات في كل مرة.

---

## هل طريقة بناء الباك اند هي السبب؟

**جزئياً.** مفيش خطوة "build" (Webpack/Babel)، لكن **طريقة رسم الباك اند** كانت غلط من ناحية التحميل والإعدادات:
- تحميل كل الـ routes والـ models والـ controllers **من أول التشغيل** كان بيملأ الذاكرة من البداية.
- إعدادات الـ pool والـ rate limiter ما كانتش مناسبة لسيرفرات صغيرة في الإنتاج.

تم تعديل الهيكلة (تحميل الـ routes عند التشغيل + تقليل الـ pool والـ rate limit في الإنتاج + request timeout لتفادي 504). التفاصيل في [BACKEND_ARCHITECTURE.md](./BACKEND_ARCHITECTURE.md).

---

## الأسباب الأكثر احتمالاً

### 1. تشغيل `npm install` على السيرفر أثناء الـ Deploy
- `npm install` بيستهلك **ذاكرة عالية** (حتى 1GB أو أكثر) خاصة مع حزم كثيرة.
- على سيرفر صغير (مثلاً 512MB أو 1GB) ده يكفي يملأ الـ RAM ويخلي السيرفر يقع أو يقتل العملية.

**الحل:**
- تنفيذ التبعيات **قبل** الرفع (مثلاً على CI أو على جهازك) ورفع مجلد `node_modules` جاهز، **أو**
- استخدام **سيرفر/بيئة بناء** أقوى لعمل `npm install` ثم رفع الناتج فقط، **أو**
- على السيرفر استخدم:
  ```bash
  NODE_OPTIONS="--max-old-space-size=512" npm ci --omit=dev
  ```
  وزيادة الـ swap إذا السيرفر ضعيف.

### 2. حجم ذاكرة السيرفر صغير
- لو الـ VPS أو السيرفر ذاكرته 512MB–1GB، عملية واحدة زي `npm install` أو Node مع ضغط عالي تكفي تعطل الخدمة.

**الحل:**
- زيادة الـ RAM أو ترقية الخطة.
- إضافة **swap** لتفادي الـ crash:
  ```bash
  sudo fallocate -l 1G /swapfile
  sudo chmod 600 /swapfile
  sudo mkswap /swapfile
  sudo swapon /swapfile
  ```

### 3. عدم تحديد حد أقصى لذكاء Node
- Node.js ممكن يطلب ذاكرة كبيرة لو مفيش حد معين، وده يزاحم باقي الخدمات على السيرفر.

**الحل:** تحديد حد للـ heap في متغير البيئة قبل تشغيل السيرفر:
```bash
# في .env أو قبل تشغيل التطبيق
NODE_OPTIONS=--max-old-space-size=384
```
(384 = 384MB كحد أقصى تقريبي؛ عدّل حسب حجم السيرفر.)

### 4. استعلامات بدون حدود (Pagination)
- بعض الـ endpoints بترجع **كل** البيانات (مثلاً كل حجوزات المستخدم، كل الـ FAQs، كل الدول) بدون `limit`.
- لو البيانات كبرت، كل طلب هيحمل مجموعة كبيرة في الذاكرة ويزيد الضغط.

**الحل:** إضافة pagination أو حد أقصى للنتائج في الـ endpoints اللي بتجيب قوائم كبيرة (تم توضيحها في الكود).

---

## خطوات Deploy موصى بها (لتقليل استهلاك الموارد)

1. **عدم الاعتماد على `npm install` على السيرفر إن أمكن**
   - بناء التبعيات في بيئة أخرى ورفع `node_modules` أو استخدام Docker/CI.

2. **تشغيل التطبيق بحد ذاكرة:**
   ```bash
   NODE_OPTIONS=--max-old-space-size=384 node src/server.js
   ```
   أو وضع نفس القيمة في `NODE_OPTIONS` في بيئة الإنتاج.

3. **استخدام process manager (مثل PM2):**
   ```bash
  npm install -g pm2
  pm2 start src/server.js --name camino-api -i 1 --max-memory-restart 400M
  ```
   - `-i 1`: عملية واحدة (مناسب للسيرفرات الصغيرة).
   - `--max-memory-restart 400M`: إعادة تشغيل التطبيق لو استهلك أكثر من 400MB.

4. **عدم تشغيل أوامر ثقيلة أثناء الـ deploy على السيرفر نفسه**
   - تجنب تشغيل `npm run seed` أو سكربتات كبيرة في نفس وقت تشغيل التطبيق؛ نفذها في وقت هادئ أو من مكان آخر.

5. **تقليل الـ logging في الإنتاج**
   - الكود الحالي يستخدم `morgan('combined')` في الإنتاج؛ مقبول، لكن لو السيرفر ضعيف جداً يمكن تقليل مستوى الـ log أو تعطيله لبعض المسارات.

---

## إصلاحات إضافية (لتقليل سقوط السيرفر)

- **حد حجم الـ body في الإنتاج:** في الإنتاج الـ JSON/urlencoded محدود بـ **1MB** (متغير `BODY_LIMIT` أو تلقائي). في التطوير 10MB. طلب واحد كبير كان ممكن يملأ الذاكرة.
- **حدود ثابتة على الاستعلامات:** كل الـ `findAll` بدون pagination عليها حد أقصى (دول 500، FAQs 200، وجهات 200، مجموعات 100، wishlist 100). الـ APIs اللي بتقبل `?limit=` محدودة بـ **50** كحد أقصى (trips، reviews، journal).
- **مهلة لاتصال قاعدة البيانات:** عند التشغيل، الاتصال بقاعدة البيانات عليه timeout (افتراضي 15 ثانية، متغير `DB_CONNECT_TIMEOUT_MS`) عشان السيرفر ما يعلقش لو الـ DB بطيء أو معطل.
- **تسجيل الأخطاء في الإنتاج:** في الإنتاج بنطبع رسالة الخطأ فقط (مش الـ stack أو الـ object الكامل) عشان الـ log ما يملأش الذاكرة.

لو محتاج رفع body أكبر (مثلاً للـ admin): ضع في `.env` مثلاً `BODY_LIMIT=5mb`.

---

## 504 Gateway Timeout (nginx)

لو ظهرت **504 Gateway Time-out** من nginx، معناها إن nginx استنى رد من الباك اند ومفيش رد في الوقت المحدد (غالباً 60 ثانية). ممكن يكون السبب:
1. طلب واحد بياخد وقت طويل (استعلام ثقيل أو أول طلب بعد التشغيل).
2. الباك اند وقع (OOM أو crash) فـ nginx ملقاش رد.

**ما تم في الباك اند:**
- **Request timeout:** كل طلب عليه حد أقصى 25 ثانية (متغير `REQUEST_TIMEOUT_MS`). لو الطلب ما خلصش، الباك اند بيرد 503 بدل ما يعلق، فـ nginx ما يعملش 504.
- **تحميل الـ API من أول التشغيل:** مفيش "أول طلب" بيحمّل كل حاجة وياخد وقت طويل فيسبب 504.

**لو لسه 504 بيحصل:** زوّد مهلة nginx للـ proxy. في الـ server block اللي فيه الـ proxy للباك اند:

```nginx
proxy_connect_timeout 30s;
proxy_send_timeout 60s;
proxy_read_timeout 60s;
```

لو محتاج وقت أطول لطلبات معينة: حط في `.env` مثلاً `REQUEST_TIMEOUT_MS=60000` (60 ثانية) وزوّد `proxy_read_timeout` في nginx لـ 90 أو 120.

---

## ملخص

| السبب                    | هل طريقة البناء؟ | الحل |
|--------------------------|------------------|------|
| `npm install` على السيرفر | لا               | نقل التبعيات أو استخدام swap + حد ذاكرة |
| سيرفر صغير RAM           | لا               | زيادة RAM أو إضافة swap |
| عدم حد لذكاء Node        | لا               | `NODE_OPTIONS=--max-old-space-size=384` |
| استعلامات بدون limit     | جزئياً (تصميم الكود) | إضافة pagination/limit في الـ APIs |

**الخلاصة:** طريقة "بناء" الباك اند (تشغيل Node مباشرة بدون bundle) ليست السبب. السبب غالباً **بيئة الـ deploy** (حجم السيرفر + تشغيل `npm install` + عدم حد لذاكرة Node)، مع إمكانية تحسين استهلاك الذاكرة بإضافة pagination وحد أقصى للنتائج في بعض الـ endpoints.
