# هيكلة الباك اند – الأخطاء اللي كانت موجودة والتعديلات

## المشاكل اللي كانت في طريقة "رسم" الباك اند

### 1. تحميل كل حاجة عند بداية التشغيل (Eager loading)

**الوضع القديم:**
- عند تشغيل السيرفر (`node src/server.js`) كان يتم تنفيذ `require('./routes/index')(app)` مباشرة.
- ملف الـ routes كان يحمّل كل الـ routes (public + auth + admin)، وكل route كان يحمّل كل الـ controllers الخاصة بيه.
- كل controller كان يعمل `require('../models')`، وملف الـ models كان يحمّل **كل الـ 16 موديل** مرة واحدة بـ `fs.readdirSync` و loop من الـ require.
- النتيجة: **من أول ثانية** السيرفر كان بيحمّل في الذاكرة: Express + كل الـ middleware + كل الـ routes + كل الـ controllers (أكتر من 20) + كل الـ models (16) + Sequelize. على سيرفر صغير (512MB–1GB) ده كان يكفي يملأ الـ RAM أو يخلي الـ process يقع أثناء الـ startup.

**الخطأ الهيكلي:**  
ما كانش في فصل بين "تشغيل خفيف" و "تحميل المنطق الثقيل". كل المنطق كان بيتحمّل قبل ما السيرفر يرد على أي طلب، فـ **طريقة رسم الباك اند كانت فعلاً بتسبب ضغط على الموارد من أول التشغيل**.

---

### 2. حجم الـ connection pool والـ rate limiter

**الوضع القديم:**
- **قاعدة البيانات:** الـ pool كان `min: 2, max: 10` في كل البيئات. على سيرفر صغير، 10 اتصالات دائمة + الـ Node + الـ models كلها = استهلاك ذاكرة عالي.
- **Rate limiter:** كان بيستخدم مخزن في الذاكرة (in-memory) مع نافذة 15 دقيقة و 100 طلب. كل IP بيضيف سجل في الذاكرة، فكل ما عدد الـ IPs يزيد، الذاكرة بتزيد بدون حد واضح.

**الخطأ الهيكلي:**  
الإعدادات ما كانتش متكيفة مع بيئة الإنتاج على سيرفرات صغيرة، فـ **رسم الإعدادات** (بدون تمييز بين dev و production) كان بيشارك في مشكلة الموارد.

---

### 3. عدم وجود حد لاستهلاك الذاكرة

- عملية Node نفسها ما كانش عليها حد أقصى للـ heap، فلو التطبيق أو أي require ثقيل طلب ذاكرة كتير، الـ process كان ممكن يكبر ويخلي السيرفر يقع.

---

## التعديلات اللي اتعملت (الهيكلة الجديدة)

### 1. تحميل الـ API routes عند التشغيل + Request timeout

**التصميم الحالي:**
- الـ API routes بتتحمّل **من أول التشغيل** (`require('./routes/index')(app)` في `app.js`). تم إلغاء الـ lazy-load لأن "أول طلب" كان بيحمّل كل حاجة وياخد وقت طويل → **504 Gateway Timeout** من nginx، وذروة الذاكرة على أول طلب كانت ممكن توقع السيرفر.
- تم إضافة **request timeout**: كل طلب عليه حد أقصى 25 ثانية (متغير `REQUEST_TIMEOUT_MS`). لو الطلب ما خلصش، الباك اند بيرد **503** بدل ما يعلق، فـ nginx ما يعملش 504.

**النتيجة:**
- التشغيل بيحمّل كل الـ routes والـ models مرة واحدة عند البداية (مع تقليل الـ pool وحدود الاستعلامات وحد الـ body عشان الذاكرة تبقى تحت السيطرة).
- مفيش طلب "أول واحد" بطيء يسبب 504.
- أي طلب بياخد وقت طويل بياخد رد 503 قبل ما nginx يعمل 504.

---

### 2. تقليل استهلاك الموارد في الإنتاج

- **قاعدة البيانات (`config/database.js`):**  
  في الإنتاج: `pool.min = 1`, `pool.max = 5` (بدل 2 و 10). تقليل عدد الاتصالات الدائمة بيقلّل الضغط على الذاكرة.

- **Rate limiter (`app.js`):**  
  في الإنتاج: نافذة 5 دقائق و 80 طلب كحد أقصى (بدل 15 دقيقة و 100). تقليل المدة والعدد بيقلّل حجم الـ store في الذاكرة. للضغط الأعلى يُفضّل استخدام Redis store لاحقاً.

---

### 3. مسارات خفيفة

- **`/health`** و **`/`** مسجّلين قبل الـ API routes، والـ load balancer أو الـ health checks تقدر تستدعي `/health` بسرعة.

---

## ملخص: هل الباك اند كان مبني غلط؟

| الجانب | كان غلط؟ | التعديل |
|--------|----------|---------|
| تحميل كل الـ routes من أول التشغيل + عدم حد للطلبات | جزئياً – أول طلب مع lazy-load كان يسبب 504 | تحميل الـ API عند التشغيل + request timeout (25 ثانية) |
| حجم الـ pool والـ rate limiter واحد لكل البيئات | ✅ نعم | تقليل الـ pool والـ rate limit في الإنتاج |
| عدم وجود حد لاستهلاك Node للذاكرة | ✅ نعم | استخدام `NODE_OPTIONS=--max-old-space-size=...` و `start:prod` (كما في DEPLOYMENT_RESOURCES.md) |

**الخلاصة:** التعديلات بتقلّل استهلاك الذاكرة (حد الـ body، حدود الاستعلامات، pool، rate limit) وبتمنع 504 عبر request timeout وتحميل الـ API من أول التشغيل.

---

## ترتيب التحميل بعد التعديل

1. **Startup:** `server.js` → `app.js` → Express + middleware + request timeout → `require('./routes/index')(app)` → publicRoutes, authRoutes, adminRoutes → كل الـ controllers → `models/index` → كل الـ 16 موديل.
2. **أي طلب:** الـ routes والـ models جاهزين؛ لو الطلب ياخد أكتر من 25 ثانية (أو `REQUEST_TIMEOUT_MS`) الباك اند بيرد 503.
